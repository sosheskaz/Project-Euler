# Performance Profiles

These profiles are a categorization of the relative performance of my implementations of these
problems. I typically care a lot about code performance, so I generally pay a lot of attention to
Clock Time and Memory Footprint in particular.

This data is made available for programmatic processing via JSON and YAML, as well as
human-consumable CSV and markdown.

## The Profiler

I made my own basic profiler in golang. Containerizing the profiler gave need for a binary I can use
for profiling that is universal, and since docker uses an API for communication (and in some cases
even a hypervisor), getting this information without guaranteeing a binary on the container in
question posed an issue.

The profiler does two things. The first is provide information to some of the same basic information
that the GNU `time` utility provides, but it also generates its own "Best Effort" of clock time.
It is generated by the binary itself, not given by the kernel, and so it _is not accurate_. That
said, it's usually good enough for my purposes.

## Profile Strategies

In general, I attempt to be _fair_ in the profiles I use. This is why, typically, there is only one
profile strategy I use - "The truth doesn't need handling". However, there are exceptions to this.
Generally, by "fair", I mean:

* Fairly Adjusted for startup and/or compile time (if it's a compiled language, don't include compile time)
* Makes reasonable accomodations for different runtime environments

### Python

For Python, I use both CPython3 and PyPy3. This is really more just idle curiosity over the deltas
between the two python interpreters rather than anything else.

A note on `pyc`: I know I said that I'd adjust for compile time, and python has `pyc`/`pyo`, but
frankly, I don't feel the performance impact of running files this small as `.py` is sufficient to
justify that, especially given that ruby and node do not get the same luxuries.

### Groovy

The JVM is a tricky subject for profiling, and I couldn't come up with a "fair" way to attack it.
Aside from that, groovy is a weird mutt of compiled and interpreted that's difficult to classify.
So I made two profiling strategies that both need to be used to get a good picture.

These strategies are `Standard` and `NailGun`. NailGun uses Facebook's NailGun framework, which is
a persistent JVM framework, in order to remove the overhead of JVM cold starts from the clock time.
However, the problem with this is that the kernel information of that process usage doesn't actually
assess the JVM itself, which means that User Time, System Time, and Memory Usage are meaningless.
Therefore, I added `Standard` which uses the normal `groovy` binary. This has additional downsides,
namely increasing the user time, system time, and memory footprint by including JVM startup and
groovy compilation.

Granted, this is not the _fairest possible_ system, and I may spend more time improving it in the
future, but it should offer usable points of comparison to other profile strategies.
